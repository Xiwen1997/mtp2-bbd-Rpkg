% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solver_fpn.R
\name{solver_fpn}
\alias{solver_fpn}
\title{Fast projected Newton-like algorithm for precision matrix estimation under nonnegative partial correlations}
\usage{
solver_fpn(S, lmbd, opts = NULL)
}
\arguments{
\item{S}{Sample covariacne matrix}

\item{lmbd}{Regularization coefficient or regularization matrix}

\item{opts}{stopping criterion options, passed as a list. Possible field name values:
(1) 'max_iter'  : maximum number of iterations
(2) 'max_time'  : maximum time
(3) 'tol'       : tolerance, the algorithm stops if ||X_k+1 - X_k||_F / ||X_k||_F < tol
(4) 'beta'      : parameter used in backtracking line search
(5) 'X_opt'     : exists if the optimal solution is available for computing the objective function error
(6) 'edge'      : exists if a disconnectivity set is imposed
(7) 'display'   : "1" if display the iteration results, "0" otherwise.}
}
\value{
A list containing the following elements:
\item{\code{time}}{Run time cost before algorithm stopped.}
\item{\code{X_est}}{The estimated precision matrix.}
\item{\code{objective}}{The objective function value when algorithm stopped}
\item{\code{obj_itr}}{Store the objective function value for each iteration}
\item{\code{time_itr}}{Store the cpu time for each iteration.}
\item{\code{iterate}}{The number of iterations cost before algorithm stopped.}
\item{\code{relobj_itr}}{Exists if 'X_opt' exists, store the relative error of the objective function value for each iteration, i.e., |fk - fopt|/|fopt|}
\item{\code{relerr_iter}}{Exists if 'X_opt' exists, store the relative error of each iteration, i.e., ||X_k - X_opt||_F / ||X_opt||_F}
\item{\code{converge}}{ "1": algorithm converges; "0" algorithm does not converge.}
}
\description{
Fast projected Newton-like algorithm for precision matrix estimation under nonnegative partial correlations
\preformatted{
  minimize     -log det(Theta) + <Theta, S> + sum_{i neq j} Lambda_{ij} |Theta_{ij}|
  subject to   Theta > 0, Theta_{ij} <=0 forall i neq j
}
}
\examples{
library(mtp2bbd)
library(igraph)
p <- 100 # problem dimension
BA_graph <- barabasi.game(p,  directed = FALSE)
adjacency_matrix <- as_adjacency_matrix(BA_graph,  type = c("both"))
max_eig          <- eigen(adjacency_matrix)$values[1]
A                <- 1.05*max_eig*diag(p) - adjacency_matrix
inv_A            <- solve(A)
D                <- diag(sqrt(diag(inv_A)))
Mtrue            <- D \%*\% A \%*\% D
X                <- MASS::mvrnorm(5 * p , mu = rep(0, p), Sigma = solve(Mtrue))
S                <- cov(X)
fpn_res          <- solver_fpn(S, 0.2)

}
\references{
J.-F. Cai, J. V. de Miranda Cardoso, D. P. Palomar, and J. Ying, "Fast Projected Newton-like Method for Precision Matrix Estimation under Total Positivity", accepted in Neural Information Processing Systems (NeurIPS), New Orleans, LA, USA, Dec. 2023.
}
\author{
Jiaxi Ying, Xiwen Wang, and Daniel P. Palomar
}
